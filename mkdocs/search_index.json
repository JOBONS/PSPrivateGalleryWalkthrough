{
    "docs": [
        {
            "location": "/",
            "text": "About\n\n\nThis site (and the repository it's generated from) exists to help demonstrate and walk you through deploying a PowerShell Private Gallery to Azure via Azure Resource Manager templates, PowerShell Desired State Configurations, and some version controlled scripts all executed via Visual Studio Services' builds.\n\n\nThe project is broken up into a couple of pieces:\n\n\n\n\nGetting Started\n\n\nStep-By-Step\n\n\nConcepts\n\n\n\n\nGetting Started\n\n\nThe \nGetting Started\n section exists to help you get the prerequisite tasks accomplished and help you to get ready for the \nStep-By-Step\n section.\nIn it you'll find information on forking this repository, setting up VSTS, and preparing your Azure subscription.\n\n\nStep-By-Step\n\n\nThe \nStep-By-Step\n section is exactly what it says on the label: a step-by-step guide to deploying the PowerShell Private Gallery.\nThis section will take you from having the prerequisites in place through deployment to operational validation and package uploading/downloading.\n\n\nConcepts\n\n\nDuring the \nStep-By-Step\n process you'll occasionally be pointed to a link over in the \nConcepts\n section.\nThese documents are explanations of terminology, dives into theory, or just tangents on topics that don't directly correlate to getting the private gallery deployed but are still useful to know.\n\n\nThis Repository\n\n\nThis repository and the project are living things - expect to see the topics and guides updated and fixed over time.\n\n\nSpeaking of errors and corrections, I immediately claim responsibility for every single error or problem you find here.\n\nPlease\n let me know when you come across spelling or grammer errors, code errors, inconsistencies, or other problems with the documentation or the configurations/templates.\n\n\nIf you have ideas for improving the project, templates, configurations, scripts, documentation, or anything else, file an issue or launch a pull request! Help is \ndefinitely\n welcome on this!\n\n\nReport Issue\n\n\nActive Issues",
            "title": "About"
        },
        {
            "location": "/#about",
            "text": "This site (and the repository it's generated from) exists to help demonstrate and walk you through deploying a PowerShell Private Gallery to Azure via Azure Resource Manager templates, PowerShell Desired State Configurations, and some version controlled scripts all executed via Visual Studio Services' builds.  The project is broken up into a couple of pieces:   Getting Started  Step-By-Step  Concepts",
            "title": "About"
        },
        {
            "location": "/#getting-started",
            "text": "The  Getting Started  section exists to help you get the prerequisite tasks accomplished and help you to get ready for the  Step-By-Step  section.\nIn it you'll find information on forking this repository, setting up VSTS, and preparing your Azure subscription.",
            "title": "Getting Started"
        },
        {
            "location": "/#step-by-step",
            "text": "The  Step-By-Step  section is exactly what it says on the label: a step-by-step guide to deploying the PowerShell Private Gallery.\nThis section will take you from having the prerequisites in place through deployment to operational validation and package uploading/downloading.",
            "title": "Step-By-Step"
        },
        {
            "location": "/#concepts",
            "text": "During the  Step-By-Step  process you'll occasionally be pointed to a link over in the  Concepts  section.\nThese documents are explanations of terminology, dives into theory, or just tangents on topics that don't directly correlate to getting the private gallery deployed but are still useful to know.",
            "title": "Concepts"
        },
        {
            "location": "/#this-repository",
            "text": "This repository and the project are living things - expect to see the topics and guides updated and fixed over time.  Speaking of errors and corrections, I immediately claim responsibility for every single error or problem you find here. Please  let me know when you come across spelling or grammer errors, code errors, inconsistencies, or other problems with the documentation or the configurations/templates.  If you have ideas for improving the project, templates, configurations, scripts, documentation, or anything else, file an issue or launch a pull request! Help is  definitely  welcome on this!  Report Issue  Active Issues",
            "title": "This Repository"
        },
        {
            "location": "/Getting-Started/",
            "text": "Getting Started\n\n\nBefore we can deploy a PowerShell Private Gallery, we need to nail down a few prerequisites.\n\n\nPrerequisites\n\n\n\n\nAn Azure account\n\n\nA Visual Studio Team Services account\n\n\nA fork of this repository\n\n\n\n\nGetting an Azure Account\n\n\nIf you don't already have a Microsoft Azure account, you can sign up for one \nhere\n.\nThis option will sign you up for an Azure Account with a $200 credit - that credit expires at the end of your first month though, so be aware of this!\n\n\nIf you're a student, you may want to use your \nDreamSpark account\n with Azure.\n\n\nIf you're an MSDN subscriber, you \ndefinitely\n want to hook up your MSDN account to Azure - you get \nup to $150 per month in credits\n!\n\n\nSetting up Visual Studio Team Services\n\n\nThe first thing to do is to \nsign up\n.\nOnce you're signed up, you'll need to create a team project - for the rest of the Walkthrough we're going to assume that you've called the project 'PSPrivateGallery'.\nThe URL for this should look something like \nhttps://youraccountname.visualstudio.com/PSPrivateGallery\n.\n\n\nForking this Repository\n\n\nTo fork this repository, first go to the repository's \npage\n on Github.\nThen click the \nFork\n button in the top right corner.\nYou should now have a fork of the repository in your own account.\n\n\nPowerShell Modules\n\n\nYou'll need the AzureRM PowerShell modules installed to create your VSTS Service Principal.\nIf you have PowerShell v5, this is relatively straightforward:\n\n\nFind-Module AzureRM | Install-Module -Force -Scope CurrentUser\n\n\n\n\nNote:\n If you'd like to install the module for everyone on the computer, you can drop \n-Scope CurentUser\n - however, you'll need to run the command with administrator rights.\n\n\nCreate a Visual Studio Team Services Service Principal Account\n\n\nIn order to connect our Azure account to VSTS, we'll need to generate a Service Principal Account.\nThe easiest way is to follow the directions \nhere\n from the MSDN Blog.\nAll we've done here is to pull the script into our script folder (Add-AzureServicePrincipal.ps1).\n\n\nThe short version, if you just want to get started, is to run that script on your local machine.\nYou'll need to know your Azure Subscription name and specify a password for the Service Principal.\n\n\nFor example (assuming you've opened a powershell prompt at the root of your local clone of this repository:\n\n\nPush-Location .\\Scripts\n.\\Add-AzureServicePrincipal.ps1 -subscriptionName 'MySubName' -Password 'SomeS35ure Password, hahahah! :D'\nPop-Location\n\n\n\n\nYou should get output like the block below; Save it in a notepad! You're going to need it for Step Two!\n\n\n***************************************************************************\nConnection Name: MySubName(SPN)\nSubscription Id: dbcdf31c-a2fb-4e27-a0ec-0af48fdb03ac\nSubscription Name: MySubName\nService Principal Id: 1670693b-0c9e-4782-ac17-4e2c27064995\nService Principal key: <Password that you typed in>\nTenant Id: 8494debb-26c9-47c3-85bf-35ee23d3ae01\n***************************************************************************\n\n\n\n\nSave that output! We're going to use it in \n\n\nFinally!\n\n\nThat's it, you've got all the prerequisites for this walkthrough now.\nNext up: adding your fork to VSTS.",
            "title": "Getting Started"
        },
        {
            "location": "/Getting-Started/#getting-started",
            "text": "Before we can deploy a PowerShell Private Gallery, we need to nail down a few prerequisites.",
            "title": "Getting Started"
        },
        {
            "location": "/Getting-Started/#prerequisites",
            "text": "An Azure account  A Visual Studio Team Services account  A fork of this repository",
            "title": "Prerequisites"
        },
        {
            "location": "/Getting-Started/#getting-an-azure-account",
            "text": "If you don't already have a Microsoft Azure account, you can sign up for one  here .\nThis option will sign you up for an Azure Account with a $200 credit - that credit expires at the end of your first month though, so be aware of this!  If you're a student, you may want to use your  DreamSpark account  with Azure.  If you're an MSDN subscriber, you  definitely  want to hook up your MSDN account to Azure - you get  up to $150 per month in credits !",
            "title": "Getting an Azure Account"
        },
        {
            "location": "/Getting-Started/#setting-up-visual-studio-team-services",
            "text": "The first thing to do is to  sign up .\nOnce you're signed up, you'll need to create a team project - for the rest of the Walkthrough we're going to assume that you've called the project 'PSPrivateGallery'.\nThe URL for this should look something like  https://youraccountname.visualstudio.com/PSPrivateGallery .",
            "title": "Setting up Visual Studio Team Services"
        },
        {
            "location": "/Getting-Started/#forking-this-repository",
            "text": "To fork this repository, first go to the repository's  page  on Github.\nThen click the  Fork  button in the top right corner.\nYou should now have a fork of the repository in your own account.",
            "title": "Forking this Repository"
        },
        {
            "location": "/Getting-Started/#powershell-modules",
            "text": "You'll need the AzureRM PowerShell modules installed to create your VSTS Service Principal.\nIf you have PowerShell v5, this is relatively straightforward:  Find-Module AzureRM | Install-Module -Force -Scope CurrentUser  Note:  If you'd like to install the module for everyone on the computer, you can drop  -Scope CurentUser  - however, you'll need to run the command with administrator rights.",
            "title": "PowerShell Modules"
        },
        {
            "location": "/Getting-Started/#create-a-visual-studio-team-services-service-principal-account",
            "text": "In order to connect our Azure account to VSTS, we'll need to generate a Service Principal Account.\nThe easiest way is to follow the directions  here  from the MSDN Blog.\nAll we've done here is to pull the script into our script folder (Add-AzureServicePrincipal.ps1).  The short version, if you just want to get started, is to run that script on your local machine.\nYou'll need to know your Azure Subscription name and specify a password for the Service Principal.  For example (assuming you've opened a powershell prompt at the root of your local clone of this repository:  Push-Location .\\Scripts\n.\\Add-AzureServicePrincipal.ps1 -subscriptionName 'MySubName' -Password 'SomeS35ure Password, hahahah! :D'\nPop-Location  You should get output like the block below; Save it in a notepad! You're going to need it for Step Two!  ***************************************************************************\nConnection Name: MySubName(SPN)\nSubscription Id: dbcdf31c-a2fb-4e27-a0ec-0af48fdb03ac\nSubscription Name: MySubName\nService Principal Id: 1670693b-0c9e-4782-ac17-4e2c27064995\nService Principal key: <Password that you typed in>\nTenant Id: 8494debb-26c9-47c3-85bf-35ee23d3ae01\n***************************************************************************  Save that output! We're going to use it in",
            "title": "Create a Visual Studio Team Services Service Principal Account"
        },
        {
            "location": "/Getting-Started/#finally",
            "text": "That's it, you've got all the prerequisites for this walkthrough now.\nNext up: adding your fork to VSTS.",
            "title": "Finally!"
        },
        {
            "location": "/Step-By-Step/1-Adding-Your-Fork-to-VSTS/",
            "text": "Adding Your Fork to VSTS\n\n\nFirst, navigate to your VSTS project - it should be something like \nhttps://youraccountname.visualstudio.com/PSPrivateGallery\n if you set it up during the \nGetting Started\n tutorial.\nOnce you're there, click the small cog in the top righthand corner.\n\n\n\n\nThis will open a new tab and bring you to the control panel for the project.\nSelect the 'Services' tab, then click on the 'New Service Endpoint' option on the top left and choose 'Github' from the drop down menu.\n\n\n\n\nOn the pop up, click the 'Authorize' button and follow the directions to authenticate, if any.\nAfter authentication, the connection name should automatically populate and you should see a message and green check mark indicated you're authenticated.\nClick OK.\n\n\n\n\nSwitch tabs back to the your project page and click the menu option for 'BUILD'.\n\n\n\n\nOnce on the build page, click the green plus sign on the top left; this will prompt you to create a new build definition.\nSelect the 'Empty' option at the bottom of the prompt, then click 'Next'.\n\n\n\n\nOn the setting page, choose Github and make sure the Default agent queue is set to 'Hosted'. Then click 'Create'.\n\n\n\n\nSelect the Repository tab under the Build definition.\nYou should see that it has autofilled the connection, repository, and default branch.\nChange the repository setting to \n<yourusername>/PSPrivateGalleryWalkthrough\n.\n\n\nClick the save button - name your build something descriptive - 'Deploy-Gallery' for example.\n\n\nThat's it!\nNext, we're going to look at adding an Azure endpoint.",
            "title": "1. Adding Your Fork to VSTS"
        },
        {
            "location": "/Step-By-Step/1-Adding-Your-Fork-to-VSTS/#adding-your-fork-to-vsts",
            "text": "First, navigate to your VSTS project - it should be something like  https://youraccountname.visualstudio.com/PSPrivateGallery  if you set it up during the  Getting Started  tutorial.\nOnce you're there, click the small cog in the top righthand corner.   This will open a new tab and bring you to the control panel for the project.\nSelect the 'Services' tab, then click on the 'New Service Endpoint' option on the top left and choose 'Github' from the drop down menu.   On the pop up, click the 'Authorize' button and follow the directions to authenticate, if any.\nAfter authentication, the connection name should automatically populate and you should see a message and green check mark indicated you're authenticated.\nClick OK.   Switch tabs back to the your project page and click the menu option for 'BUILD'.   Once on the build page, click the green plus sign on the top left; this will prompt you to create a new build definition.\nSelect the 'Empty' option at the bottom of the prompt, then click 'Next'.   On the setting page, choose Github and make sure the Default agent queue is set to 'Hosted'. Then click 'Create'.   Select the Repository tab under the Build definition.\nYou should see that it has autofilled the connection, repository, and default branch.\nChange the repository setting to  <yourusername>/PSPrivateGalleryWalkthrough .  Click the save button - name your build something descriptive - 'Deploy-Gallery' for example.  That's it!\nNext, we're going to look at adding an Azure endpoint.",
            "title": "Adding Your Fork to VSTS"
        },
        {
            "location": "/Step-By-Step/2-Adding-Azure-to-VSTS/",
            "text": "Adding Azure to VSTS\n\n\nHopefully, you've generated an Azure Service Principal Account from the \nGetting Started\n prerequisites section.\nIf not, you'll need to do so or generate a service principal through other means.\n\n\nNavigate back to the admin settings for your VSTS project's Service Endpoints - the url should be like \nhttps://youraccountname.visualstudio.com/PSPrivateGallery/_admin/_services\n but with your VSTS account name instead of 'youraccountname'.\nFrom here, you'll want to add an Azure RM Service Endpoint as we did for Github.\n\n\n\n\nRemember that data we saved when creating the Service Principal account?\nThis is where we're going to use it.\nCopy the correct values into the form - the script we used helpfully identifies everything for you.\nMake sure to put the password you created for the account in for the \nService Principal Key\n's value.\n\n\nClick okay, and you should see your Service Principal account added as an endpoint on the left.\n\n\n\nThis was a short step - next, we're going to create our build definition!",
            "title": "2. Adding Azure to VSTS"
        },
        {
            "location": "/Step-By-Step/2-Adding-Azure-to-VSTS/#adding-azure-to-vsts",
            "text": "Hopefully, you've generated an Azure Service Principal Account from the  Getting Started  prerequisites section.\nIf not, you'll need to do so or generate a service principal through other means.  Navigate back to the admin settings for your VSTS project's Service Endpoints - the url should be like  https://youraccountname.visualstudio.com/PSPrivateGallery/_admin/_services  but with your VSTS account name instead of 'youraccountname'.\nFrom here, you'll want to add an Azure RM Service Endpoint as we did for Github.   Remember that data we saved when creating the Service Principal account?\nThis is where we're going to use it.\nCopy the correct values into the form - the script we used helpfully identifies everything for you.\nMake sure to put the password you created for the account in for the  Service Principal Key 's value.  Click okay, and you should see your Service Principal account added as an endpoint on the left.  This was a short step - next, we're going to create our build definition!",
            "title": "Adding Azure to VSTS"
        },
        {
            "location": "/Step-By-Step/3-Defining-Your-VSTS-Build/",
            "text": "Creating your Build Defintion\n\n\nNow we're finally to the interesting part - defining our build.\nWe're going to set the build up to create the resource group, which will deploy the VM, the network security rules, the network, storage, and DNS entries, as well as apply the Desired State Configurations to the new VM.\n\n\nAdd the Build Variables\n\n\nBefore we add the build tasks, we need to define some useful variables.\n\n\n\n\nSelect the 'Variables' tab of the build definition.\n\n\nSelect 'Add Variable' and add the following value under the 'Name' column: \nresourceGroupName\n\n\nSelect the 'Allow at Queue Time' checkbox.\n\n\n\n\nYou're going to add several more variables here, per the table below:\n\n\n\n\n\n\n\n\nName\n\n\nSecret\n\n\nAllow at Queue Time\n\n\n\n\n\n\n\n\n\n\nresourceGroupName\n\n\nfalse\n\n\ntrue\n\n\n\n\n\n\nvmName\n\n\nfalse\n\n\ntrue\n\n\n\n\n\n\nvmAdminAccount\n\n\nfalse\n\n\ntrue\n\n\n\n\n\n\nvmAdminPassword\n\n\ntrue\n\n\ntrue\n\n\n\n\n\n\ngalleryAdminPassword\n\n\ntrue\n\n\ntrue\n\n\n\n\n\n\ngalleryUserPassword\n\n\ntrue\n\n\ntrue\n\n\n\n\n\n\ngalleryApiKey\n\n\nfalse\n\n\ntrue\n\n\n\n\n\n\ngalleryEmailAddress\n\n\nfalse\n\n\ntrue\n\n\n\n\n\n\ngalleryName\n\n\nfalse\n\n\ntrue\n\n\n\n\n\n\n\n\nYou can place any string you like in for the value of \nresourcegroupName\n, \nvmName\n, and \nvmAdminAccount\n; these will, unsurprisingly, define the name of the Azure resource group to be created (and in which the gallery will reside), the name of the virtual machine the gallery will be installed on, and the name of the admin account created on the VM.\n\n\nSimilarly, you'll want to supply a guid for the GalleryApiKey - this is the API key that members of your organization will use to publish modules to the private gallery.\nYou may want to mark this as a secret as well, for security purposes.\n\n\nSpeaking of secrets, notice that all of the 'Password' variables are marked as \nSecret\n - that allows you to safely and securely save the VM Admin's password, the Gallery Admin's password, and the Gallery User's password in the build definition.\nYou'll be able to unhide them until you save the build definition - at which point you won't be able to retrieve the secret outside of a build.\n\n\nFinally, you'll want to specify an email address for the private gallery - an organizational mailbox or an individual, depending on the scope of your userbase - and a name for your gallery.\n\n\nFor all of these values we've elected to make them available for overriding at queue time.\nThat means we're going to be able to specify any/all of them whenever we run a build.\n\n\nAdd the Resource Group Deployment Task\n\n\nIn your build definition, select the 'Add a Build Step' button.\n\n\nThis will bring up a menu - select the the 'Deploy' tab, and then the 'Azure Resource Group Deployment' option on that tab.\n\n\nClick the 'Close' button to return to the build.\n\n\n\n\nConfiguring the Resource Group Deployment Task\n\n\nYou'll notice, now that you've added the Resource Group Deployment task, that there's more than a few parts of it to configure!\nNo worries though, we're going to tackle them one by one.\n\n\n\n\nSet the \nAzure Connection Type\n to 'Azure Resource Manager'\n\n\nSelect your subscription from the \nAzure RM Subscription\n drop-down - it should match your VSTS Service Principal account.\n\n\nEnsure the \nAction\n is set to 'Create or Update Resource Group'\n\n\nSet \nResource Group\n to \n$(resourceGroupName)\n\n\nSet \nLocation\n to wherever you please.\nThis demo was tested against the East US region, but should work everywhere.\n\n\nSet \nTemplate\n to \nTemplates/azuredeploy.json\n\nThis points to the path for the template so the build knows what to do.\n\n\nSet \nTemplate Parameters\n to \nTemplates/azuredeploy.parameters.json\n\nThis has some default parameters for the build - including VM Size.\n\n\nSet \nOverride Template Parameters\n to '-newStorageAccountName $(vmName) -dnsNameForPublicIP $(vmName) -adminUsername $(vmAdminAccount) -adminPassword (ConvertTo-SecureString -String $(vmAdminPassword) -AsPlainText -Force) -vmName $(vmName)'\n\nMake sure not to include the wrapping quotation marks though!\n\n\nEnsure \nEnable Deployment Prerequisites\n is checked.\n\n\nSet \nResource Group\n under the \nOutput\n section to \nresourceGroup\n.\nThis will allow us to pass the resource group directly over to the final build step when we're running a PowerShell script on the newly created VM.\n\n\n\n\nApart from Step 8, most of the steps for configuring the resource deployment are reasonably straight forward.\nIn that step, we're overriding the parameters as if we were at a PowerShell prompt - because, when this build task runs, we are!\n\n\nSo we specify that the Storage Account should be named for the VM it's attached to, as should the DNS name and, of course, the VM itself!\nWe give the Admin account a name (specified in the build variables) and then do some work to pass through the password as a secure string.\n\n\nConvertTo-SecureString -String $(vmAdminPassword) -AsPlainText -Force\n\n\n\n\nThe secret stored in the build system is \nnot\n stored as a secure string, just kept safe until deployment.\nSo, when we want to pass it in for the VM's admin account password, we need to ensure it gets converted.\nOtherwise, the build will error out! \n\n\nAdd the Tasks for Copying Files to the Gallery VM\n\n\nIn the repository are some prerequisite files we need to get onto the VM so the configuration can run.\nWe're going to copy a few PowerShell modules for the DSC resources - one for Package Management, one for SQLExpress, one for IIS, and (of course!) the PSGallery DSC resource.\n\n\nThen we're going to copy over some installer files these resources will look for - namely, the installers for SQL and an IIS component.\n\n\nFinally, we're going to copy over the Configuration files themselves!\n\n\nTo do this, we're going to add a build step and navigate to the 'Deploy' tab.\nSelect the 'Azure File Copy' option, and add it \nthree\n times.\nClick okay to close the menu again.\n\n\n\n\nNext, we're going to configure each of these tasks.\n\n\nConfiguring the First Azure File Copy Task: Pushing the Modules\n\n\nAs before, let's tackle the settings one after another:\n\n\n\n\nSet the \nSource\n to \nModules\n.\nThis ensures that the task will copy the Modules folder from the repository.\n\n\nSet the \nAzure Connection Type\n to 'Azure Resource Manager'\n\n\nSet the \nAzure RM Subscription\n to your Service Principal account from the drop down again.\n\n\nSet the \nDestination Type\n to 'Azure VMs'\n\n\nSet the \nRM Storage Account\n to \n$(vmName)\n\n\nSet the \nResource Group\n to \n$(resourceGroupName)\n\n\nEnsure \nSelect Machines By\n is set to 'Machine Names'.\n\n\nSet the \nAdmin Login\n to \n$(vmAdminAccount)\n\n\nSet the \nPassword\n to \n$(vmAdminPassword)\n\n\nSet the \nDestination\n to \nC:\\Program Files\\WindowsPowerShell\\Modules\n\n\nEnsure that \nEnable Copy Prerequisites\n and \nTest Certificate\n are both checked.\nThis ensures that you're able to copy the files over to the VM.\nWithout these settings, the copy will fail - the build server can't copy over HTTP because the newly created Gallery VM isn't in the build server's \nTrusted Hosts List\n.\n\n\n\n\nThat's it. \nNow, to configure the next two tasks...\n\n\nConfiguring the Second Azure File Copy Task: Pushing the Installers\n\n\nThe settings for this task are nearly the same as for the first Azure file copy task.\nHowever, this time we're copying the installers over so steps 1 and 10 (setting the source and destination, respectively) are different.\n\n\nWe've included the full step list again so you don't have to reference back and forth.\n\n\n\n\nSet the \nSource\n to \nInstallers\n.\n\n\nSet the \nAzure Connection Type\n to 'Azure Resource Manager'\n\n\nSet the \nAzure RM Subscription\n to your Service Principal account from the drop down again.\n\n\nSet the \nDestination Type\n to 'Azure VMs'\n\n\nSet the \nRM Storage Account\n to \n$(vmName)\n\n\nSet the \nResource Group\n to \n$(resourceGroupName)\n\n\nEnsure \nSelect Machines By\n is set to 'Machine Names'.\n\n\nSet the \nAdmin Login\n to \n$(vmAdminAccount)\n\n\nSet the \nPassword\n to \n$(vmAdminPassword)\n\n\nSet the \nDestination\n to \nC:\\PSPG\\Installers\n\n\nEnsure that \nEnable Copy Prerequisites\n and \nTest Certificate\n are both checked.\n\n\n\n\nConfiguring the Third Azure File Copy Task: Pushing the Configuration Files\n\n\nLast file copy task to configure!\nThis time, we're copying over the Configuration Environment data files, the scripts which define and execute the configurations, and a controller script (\nExecute-ConfigurationScripts.ps1\n) which we'll be calling in the final step of this build definition.\n\n\n\n\nSet the \nSource\n to \nConfiguration\n.\n\n\nSet the \nAzure Connection Type\n to 'Azure Resource Manager'\n\n\nSet the \nAzure RM Subscription\n to your Service Principal account from the drop down again.\n\n\nSet the \nDestination Type\n to 'Azure VMs'\n\n\nSet the \nRM Storage Account\n to \n$(vmName)\n\n\nSet the \nResource Group\n to \n$(resourceGroupName)\n\n\nEnsure \nSelect Machines By\n is set to 'Machine Names'.\n\n\nSet the \nAdmin Login\n to \n$(vmAdminAccount)\n\n\nSet the \nPassword\n to \n$(vmAdminPassword)\n\n\nSet the \nDestination\n to \nC:\\PSPG\\Configuration\n\n\nEnsure that \nEnable Copy Prerequisites\n and \nTest Certificate\n are both checked.\n\n\n\n\nNow we can move on to the final build task!\n\n\nAdding the Task to Execute the DSC Configurations\n\n\nAs before, add a build step and navigate to the 'Deploy' tab.\nSelect 'PowerShell on Target Machines', add one task, and hit okay to close the menu.\n\n\n\n\nThis is the final task in the build definition - it will run the \nExecute-ConfigurationScripts.ps1\n script file on our newly deployed VM.\nIf you're interested in exactly what it's doing, take a look at \nThe PowerShell Private Gallery Configurations\n in the \nConcepts\n section.\n\n\nFor now, we're just going to focus on the parameters being passed through for the task's configuration.\n\n\nConfiguring the Remote PowerShell Task\n\n\nOne last list of items to set for the configuration and we're ready to deploy!\nOnce again, you'll want to make sure the settings for this task are correct:\n\n\n\n\nSet the \nMachines\n to \n$(resourceGroup)\n.\nThis is the output of deploying the resource group earlier.\n\n\nSet the \nAdmin Login\n to \n$(vmAdminAccount)\n\n\nSet the \nPassword\n to \n$(vmAdminPassword)\n\n\nEnsure the \nProtocol\n is set to 'HTTPS' and that the \nTest Certificate\n option \nis\n ehecked.\nAgain, the build server won't be able to reach the new VM over HTTP because it won't be added to the build server's Trusted Hosts list.\n\n\nSet the \nPowerShell Script\n to \nC:\\PSPG\\Configuration\\Execute-ConfigurationScripts.ps1\n.\nThis is why we needed to copy the configuration folder over - we can't run a script that doesn't exist on the target!\n\n\nSet the \nScript Arguments\n to '-AdminPass $(galleryAdminPassword) -UserPass $(galleryUserPassword) -ApiKey $(galleryApiKey) -EmailAddress $(galleryEmailAddress)'\n\nAgain, make sure not to include the wrapping quotation marks!\n\n\n\n\nOnce more, the complexity is found when we're setting the parameters.\nIn this case, we're passing through the gallery admin and user passwords we specified back up in the variables section, an ApiKey (used to publish modules to our new repository), and an email address for the gallery admin.\n\n\nConclusion\n\n\nThis was a reasonably long step in the process, but it's the most important one.\nNow that we've defined the build, we can actually run it and deploy a private gallery to Azure!\n\n\nMore importantly, if we ever change our minds about any of the variables we used back up in the first section, all we need to do is edit them and redeploy.\n\n\nNext, we're going to register the repository on our local machine!",
            "title": "3. Defining Your VSTS-Build"
        },
        {
            "location": "/Step-By-Step/3-Defining-Your-VSTS-Build/#creating-your-build-defintion",
            "text": "Now we're finally to the interesting part - defining our build.\nWe're going to set the build up to create the resource group, which will deploy the VM, the network security rules, the network, storage, and DNS entries, as well as apply the Desired State Configurations to the new VM.",
            "title": "Creating your Build Defintion"
        },
        {
            "location": "/Step-By-Step/3-Defining-Your-VSTS-Build/#add-the-build-variables",
            "text": "Before we add the build tasks, we need to define some useful variables.   Select the 'Variables' tab of the build definition.  Select 'Add Variable' and add the following value under the 'Name' column:  resourceGroupName  Select the 'Allow at Queue Time' checkbox.   You're going to add several more variables here, per the table below:     Name  Secret  Allow at Queue Time      resourceGroupName  false  true    vmName  false  true    vmAdminAccount  false  true    vmAdminPassword  true  true    galleryAdminPassword  true  true    galleryUserPassword  true  true    galleryApiKey  false  true    galleryEmailAddress  false  true    galleryName  false  true     You can place any string you like in for the value of  resourcegroupName ,  vmName , and  vmAdminAccount ; these will, unsurprisingly, define the name of the Azure resource group to be created (and in which the gallery will reside), the name of the virtual machine the gallery will be installed on, and the name of the admin account created on the VM.  Similarly, you'll want to supply a guid for the GalleryApiKey - this is the API key that members of your organization will use to publish modules to the private gallery.\nYou may want to mark this as a secret as well, for security purposes.  Speaking of secrets, notice that all of the 'Password' variables are marked as  Secret  - that allows you to safely and securely save the VM Admin's password, the Gallery Admin's password, and the Gallery User's password in the build definition.\nYou'll be able to unhide them until you save the build definition - at which point you won't be able to retrieve the secret outside of a build.  Finally, you'll want to specify an email address for the private gallery - an organizational mailbox or an individual, depending on the scope of your userbase - and a name for your gallery.  For all of these values we've elected to make them available for overriding at queue time.\nThat means we're going to be able to specify any/all of them whenever we run a build.",
            "title": "Add the Build Variables"
        },
        {
            "location": "/Step-By-Step/3-Defining-Your-VSTS-Build/#add-the-resource-group-deployment-task",
            "text": "In your build definition, select the 'Add a Build Step' button.  This will bring up a menu - select the the 'Deploy' tab, and then the 'Azure Resource Group Deployment' option on that tab.  Click the 'Close' button to return to the build.",
            "title": "Add the Resource Group Deployment Task"
        },
        {
            "location": "/Step-By-Step/3-Defining-Your-VSTS-Build/#configuring-the-resource-group-deployment-task",
            "text": "You'll notice, now that you've added the Resource Group Deployment task, that there's more than a few parts of it to configure!\nNo worries though, we're going to tackle them one by one.   Set the  Azure Connection Type  to 'Azure Resource Manager'  Select your subscription from the  Azure RM Subscription  drop-down - it should match your VSTS Service Principal account.  Ensure the  Action  is set to 'Create or Update Resource Group'  Set  Resource Group  to  $(resourceGroupName)  Set  Location  to wherever you please.\nThis demo was tested against the East US region, but should work everywhere.  Set  Template  to  Templates/azuredeploy.json \nThis points to the path for the template so the build knows what to do.  Set  Template Parameters  to  Templates/azuredeploy.parameters.json \nThis has some default parameters for the build - including VM Size.  Set  Override Template Parameters  to '-newStorageAccountName $(vmName) -dnsNameForPublicIP $(vmName) -adminUsername $(vmAdminAccount) -adminPassword (ConvertTo-SecureString -String $(vmAdminPassword) -AsPlainText -Force) -vmName $(vmName)' Make sure not to include the wrapping quotation marks though!  Ensure  Enable Deployment Prerequisites  is checked.  Set  Resource Group  under the  Output  section to  resourceGroup .\nThis will allow us to pass the resource group directly over to the final build step when we're running a PowerShell script on the newly created VM.   Apart from Step 8, most of the steps for configuring the resource deployment are reasonably straight forward.\nIn that step, we're overriding the parameters as if we were at a PowerShell prompt - because, when this build task runs, we are!  So we specify that the Storage Account should be named for the VM it's attached to, as should the DNS name and, of course, the VM itself!\nWe give the Admin account a name (specified in the build variables) and then do some work to pass through the password as a secure string.  ConvertTo-SecureString -String $(vmAdminPassword) -AsPlainText -Force  The secret stored in the build system is  not  stored as a secure string, just kept safe until deployment.\nSo, when we want to pass it in for the VM's admin account password, we need to ensure it gets converted.\nOtherwise, the build will error out!",
            "title": "Configuring the Resource Group Deployment Task"
        },
        {
            "location": "/Step-By-Step/3-Defining-Your-VSTS-Build/#add-the-tasks-for-copying-files-to-the-gallery-vm",
            "text": "In the repository are some prerequisite files we need to get onto the VM so the configuration can run.\nWe're going to copy a few PowerShell modules for the DSC resources - one for Package Management, one for SQLExpress, one for IIS, and (of course!) the PSGallery DSC resource.  Then we're going to copy over some installer files these resources will look for - namely, the installers for SQL and an IIS component.  Finally, we're going to copy over the Configuration files themselves!  To do this, we're going to add a build step and navigate to the 'Deploy' tab.\nSelect the 'Azure File Copy' option, and add it  three  times.\nClick okay to close the menu again.   Next, we're going to configure each of these tasks.",
            "title": "Add the Tasks for Copying Files to the Gallery VM"
        },
        {
            "location": "/Step-By-Step/3-Defining-Your-VSTS-Build/#configuring-the-first-azure-file-copy-task-pushing-the-modules",
            "text": "As before, let's tackle the settings one after another:   Set the  Source  to  Modules .\nThis ensures that the task will copy the Modules folder from the repository.  Set the  Azure Connection Type  to 'Azure Resource Manager'  Set the  Azure RM Subscription  to your Service Principal account from the drop down again.  Set the  Destination Type  to 'Azure VMs'  Set the  RM Storage Account  to  $(vmName)  Set the  Resource Group  to  $(resourceGroupName)  Ensure  Select Machines By  is set to 'Machine Names'.  Set the  Admin Login  to  $(vmAdminAccount)  Set the  Password  to  $(vmAdminPassword)  Set the  Destination  to  C:\\Program Files\\WindowsPowerShell\\Modules  Ensure that  Enable Copy Prerequisites  and  Test Certificate  are both checked.\nThis ensures that you're able to copy the files over to the VM.\nWithout these settings, the copy will fail - the build server can't copy over HTTP because the newly created Gallery VM isn't in the build server's  Trusted Hosts List .   That's it. \nNow, to configure the next two tasks...",
            "title": "Configuring the First Azure File Copy Task: Pushing the Modules"
        },
        {
            "location": "/Step-By-Step/3-Defining-Your-VSTS-Build/#configuring-the-second-azure-file-copy-task-pushing-the-installers",
            "text": "The settings for this task are nearly the same as for the first Azure file copy task.\nHowever, this time we're copying the installers over so steps 1 and 10 (setting the source and destination, respectively) are different.  We've included the full step list again so you don't have to reference back and forth.   Set the  Source  to  Installers .  Set the  Azure Connection Type  to 'Azure Resource Manager'  Set the  Azure RM Subscription  to your Service Principal account from the drop down again.  Set the  Destination Type  to 'Azure VMs'  Set the  RM Storage Account  to  $(vmName)  Set the  Resource Group  to  $(resourceGroupName)  Ensure  Select Machines By  is set to 'Machine Names'.  Set the  Admin Login  to  $(vmAdminAccount)  Set the  Password  to  $(vmAdminPassword)  Set the  Destination  to  C:\\PSPG\\Installers  Ensure that  Enable Copy Prerequisites  and  Test Certificate  are both checked.",
            "title": "Configuring the Second Azure File Copy Task: Pushing the Installers"
        },
        {
            "location": "/Step-By-Step/3-Defining-Your-VSTS-Build/#configuring-the-third-azure-file-copy-task-pushing-the-configuration-files",
            "text": "Last file copy task to configure!\nThis time, we're copying over the Configuration Environment data files, the scripts which define and execute the configurations, and a controller script ( Execute-ConfigurationScripts.ps1 ) which we'll be calling in the final step of this build definition.   Set the  Source  to  Configuration .  Set the  Azure Connection Type  to 'Azure Resource Manager'  Set the  Azure RM Subscription  to your Service Principal account from the drop down again.  Set the  Destination Type  to 'Azure VMs'  Set the  RM Storage Account  to  $(vmName)  Set the  Resource Group  to  $(resourceGroupName)  Ensure  Select Machines By  is set to 'Machine Names'.  Set the  Admin Login  to  $(vmAdminAccount)  Set the  Password  to  $(vmAdminPassword)  Set the  Destination  to  C:\\PSPG\\Configuration  Ensure that  Enable Copy Prerequisites  and  Test Certificate  are both checked.   Now we can move on to the final build task!",
            "title": "Configuring the Third Azure File Copy Task: Pushing the Configuration Files"
        },
        {
            "location": "/Step-By-Step/3-Defining-Your-VSTS-Build/#adding-the-task-to-execute-the-dsc-configurations",
            "text": "As before, add a build step and navigate to the 'Deploy' tab.\nSelect 'PowerShell on Target Machines', add one task, and hit okay to close the menu.   This is the final task in the build definition - it will run the  Execute-ConfigurationScripts.ps1  script file on our newly deployed VM.\nIf you're interested in exactly what it's doing, take a look at  The PowerShell Private Gallery Configurations  in the  Concepts  section.  For now, we're just going to focus on the parameters being passed through for the task's configuration.",
            "title": "Adding the Task to Execute the DSC Configurations"
        },
        {
            "location": "/Step-By-Step/3-Defining-Your-VSTS-Build/#configuring-the-remote-powershell-task",
            "text": "One last list of items to set for the configuration and we're ready to deploy!\nOnce again, you'll want to make sure the settings for this task are correct:   Set the  Machines  to  $(resourceGroup) .\nThis is the output of deploying the resource group earlier.  Set the  Admin Login  to  $(vmAdminAccount)  Set the  Password  to  $(vmAdminPassword)  Ensure the  Protocol  is set to 'HTTPS' and that the  Test Certificate  option  is  ehecked.\nAgain, the build server won't be able to reach the new VM over HTTP because it won't be added to the build server's Trusted Hosts list.  Set the  PowerShell Script  to  C:\\PSPG\\Configuration\\Execute-ConfigurationScripts.ps1 .\nThis is why we needed to copy the configuration folder over - we can't run a script that doesn't exist on the target!  Set the  Script Arguments  to '-AdminPass $(galleryAdminPassword) -UserPass $(galleryUserPassword) -ApiKey $(galleryApiKey) -EmailAddress $(galleryEmailAddress)' Again, make sure not to include the wrapping quotation marks!   Once more, the complexity is found when we're setting the parameters.\nIn this case, we're passing through the gallery admin and user passwords we specified back up in the variables section, an ApiKey (used to publish modules to our new repository), and an email address for the gallery admin.",
            "title": "Configuring the Remote PowerShell Task"
        },
        {
            "location": "/Step-By-Step/3-Defining-Your-VSTS-Build/#conclusion",
            "text": "This was a reasonably long step in the process, but it's the most important one.\nNow that we've defined the build, we can actually run it and deploy a private gallery to Azure!  More importantly, if we ever change our minds about any of the variables we used back up in the first section, all we need to do is edit them and redeploy.  Next, we're going to register the repository on our local machine!",
            "title": "Conclusion"
        },
        {
            "location": "/Step-By-Step/4-Deploying-And-Registering-Your-Private-Gallery/",
            "text": "Deploying and Registering Your Private Gallery\n\n\nDeploying Your Private Gallery\n\n\nSo, assuming everything went well in \nStep 3\n, you're ready to deploy your private gallery instance to Azure.\n\n\nYou can do that from your build definition - once you've verified the task definitions and variables, save the Build Definition \nif you are using a dedicated Build Server\n. If you're using the Hosted Build Servers, you'll have to split up your build - unfortunately, the build will bust the 30m agent maximum!\n\n\nIf you're using the hosted build agent, disable the last step (the PowerShell on a Remote Machine step, which executes the configuration).\n\n\nThen click the 'Queue Build' button and VSTS will start looking for a hosted build agent to use for your build!\n\n\nBe prepared - the deployment itself can take a long time - in my tests, close to 30 minutes - to complete.\n\n\nIf you're using the Hosted Build Agent, after the build completes you'll want to edit your build definition - disable the file copies (since the files have already been copied over) and enable the PowerShell step.\nThen run the build a second time.\n\n\nNote:\n Even though you run the build a second time, the ARM Template deployment is idempotent - because no changes were made to the template, the first build step will just guarantee that the resources are in the expected state.\nThen it will move on to applying the configuration.\nThis may also take close to thirty minuts.\n\n\nYou've probably noticed that this build (or builds, if you've had to split it in half due to the free hosted agent limitations) takes a while.\nHowever, in that block of time the build is:\n\n\n\n\nDeploying a Virtual Machine, configuring a virtual network, registering a DNS entry, setting up firewall rules, and configuring storage.\n\n\nCopying modules, installers, and configuration documents to the new VM.\n\n\nConfiguring the VM - including installing and configuring both IIS and SQLExpress, configuring and standing up a website, and downloading and registering packages for the repository.\n\n\n\n\nInterlude: On Infrastucture as Code\n\n\nWhile you're waiting for the deployment to finish, here's a few questions for you:\n\n\n\n\nHow long would it take you to do those tasks by hand?\n\n\nHow confident could you be that the process was exactly what you were expecting?\n\n\nHow easily could you make a change to one step of the process and be assured that your node can be successfully redeployed?\n\n\nWhat conversations might you have with your team or organization about the settings and configuration of the gallery?\n\n\nHow can you be assured that those settings and configurations are implemented? Documented?\n\n\nHow repeatable would a manual version of this process be?\n\n\nHow quickly could you test and modify a manual process for use in another domain or environment?\n\n\n\n\nThere are no trick questions here, no clever answers.\nThe 'simple' truth is this: infrastructure as code is a way to make our deployments safer, more consistent, easier to modify, and easier for people in our team and across other teams to review, improve, and learn about the systems being deployed.\nThere's no magic involved.\n\n\nHopefully, your build should be just about finished now!\n\n\nRegistering Your Private Gallery\n\n\nAssuming your build didn't error out, you should now have a working Private Gallery!\nWant to prove it?\nOpen a PowerShell prompt on your local machine.\n\n\nRegister-PSRepository -Name '<galleryName>' -SourceLocation 'http://<vmName>.<location>.cloudapp.azure.com/api/v2' -InstallationPolicy Trusted\n\n\n\n\nMake sure to replace \n<galleryName>\n and \n<vmName>\n with whatever you used for that variable in your build definition (without the angle brackets) and \n<location>\n with whichever Azure region you deployed your private gallery to.\nFor example, if I deployed a private gallery called \nstlpsug\n on a VM called \npspg01\n in the \nEast US\n region:\n\n\nRegister-PSRepository -Name stlpsug -SourceLocation http://pspg01.eastus.cloudapp.azure.com/api/v2 -InstallationPolicy Trusted\n\n\n\n\nThen, search to see what packages are available on the remote repository (replace stlpsug with the name of your own private gallery):\n\n\nFind-Package -Repostory stlpsug\n\n\n\n\nYou should get back output like this:\n\n\nVersion    Name                                Type       Repository           Description\n-------    ----                                ----       ----------           -----------\n0.6.1.2... posh-git                            Module     stlpsug              A PowerShell environment for Git\n3.4.0      Pester                              Module     stlpsug              Pester provides a framework for runni...\n1.6.0      PSScriptAnalyzer                    Module     stlpsug              PSScriptAnalyzer provides script anal...\n0.1.15     PSDeploy                            Module     stlpsug              Module to simplify PowerShell based d...\n4.6.0      psake                               Module     stlpsug              psake is a build automation tool writ...\n0.6.1      platyPS                             Module     stlpsug              Generate PowerShell External Help fil...\n1.2        PSReadline                          Module     stlpsug              Great command line editing in the Pow...\n\n\n\n\nThat's it!\nWe've deployed \nand\n registered our very own private PowerShell repository!",
            "title": "4. Deploying and Registering Your Private Gallery"
        },
        {
            "location": "/Step-By-Step/4-Deploying-And-Registering-Your-Private-Gallery/#deploying-and-registering-your-private-gallery",
            "text": "",
            "title": "Deploying and Registering Your Private Gallery"
        },
        {
            "location": "/Step-By-Step/4-Deploying-And-Registering-Your-Private-Gallery/#deploying-your-private-gallery",
            "text": "So, assuming everything went well in  Step 3 , you're ready to deploy your private gallery instance to Azure.  You can do that from your build definition - once you've verified the task definitions and variables, save the Build Definition  if you are using a dedicated Build Server . If you're using the Hosted Build Servers, you'll have to split up your build - unfortunately, the build will bust the 30m agent maximum!  If you're using the hosted build agent, disable the last step (the PowerShell on a Remote Machine step, which executes the configuration).  Then click the 'Queue Build' button and VSTS will start looking for a hosted build agent to use for your build!  Be prepared - the deployment itself can take a long time - in my tests, close to 30 minutes - to complete.  If you're using the Hosted Build Agent, after the build completes you'll want to edit your build definition - disable the file copies (since the files have already been copied over) and enable the PowerShell step.\nThen run the build a second time.  Note:  Even though you run the build a second time, the ARM Template deployment is idempotent - because no changes were made to the template, the first build step will just guarantee that the resources are in the expected state.\nThen it will move on to applying the configuration.\nThis may also take close to thirty minuts.  You've probably noticed that this build (or builds, if you've had to split it in half due to the free hosted agent limitations) takes a while.\nHowever, in that block of time the build is:   Deploying a Virtual Machine, configuring a virtual network, registering a DNS entry, setting up firewall rules, and configuring storage.  Copying modules, installers, and configuration documents to the new VM.  Configuring the VM - including installing and configuring both IIS and SQLExpress, configuring and standing up a website, and downloading and registering packages for the repository.",
            "title": "Deploying Your Private Gallery"
        },
        {
            "location": "/Step-By-Step/4-Deploying-And-Registering-Your-Private-Gallery/#interlude-on-infrastucture-as-code",
            "text": "While you're waiting for the deployment to finish, here's a few questions for you:   How long would it take you to do those tasks by hand?  How confident could you be that the process was exactly what you were expecting?  How easily could you make a change to one step of the process and be assured that your node can be successfully redeployed?  What conversations might you have with your team or organization about the settings and configuration of the gallery?  How can you be assured that those settings and configurations are implemented? Documented?  How repeatable would a manual version of this process be?  How quickly could you test and modify a manual process for use in another domain or environment?   There are no trick questions here, no clever answers.\nThe 'simple' truth is this: infrastructure as code is a way to make our deployments safer, more consistent, easier to modify, and easier for people in our team and across other teams to review, improve, and learn about the systems being deployed.\nThere's no magic involved.  Hopefully, your build should be just about finished now!",
            "title": "Interlude: On Infrastucture as Code"
        },
        {
            "location": "/Step-By-Step/4-Deploying-And-Registering-Your-Private-Gallery/#registering-your-private-gallery",
            "text": "Assuming your build didn't error out, you should now have a working Private Gallery!\nWant to prove it?\nOpen a PowerShell prompt on your local machine.  Register-PSRepository -Name '<galleryName>' -SourceLocation 'http://<vmName>.<location>.cloudapp.azure.com/api/v2' -InstallationPolicy Trusted  Make sure to replace  <galleryName>  and  <vmName>  with whatever you used for that variable in your build definition (without the angle brackets) and  <location>  with whichever Azure region you deployed your private gallery to.\nFor example, if I deployed a private gallery called  stlpsug  on a VM called  pspg01  in the  East US  region:  Register-PSRepository -Name stlpsug -SourceLocation http://pspg01.eastus.cloudapp.azure.com/api/v2 -InstallationPolicy Trusted  Then, search to see what packages are available on the remote repository (replace stlpsug with the name of your own private gallery):  Find-Package -Repostory stlpsug  You should get back output like this:  Version    Name                                Type       Repository           Description\n-------    ----                                ----       ----------           -----------\n0.6.1.2... posh-git                            Module     stlpsug              A PowerShell environment for Git\n3.4.0      Pester                              Module     stlpsug              Pester provides a framework for runni...\n1.6.0      PSScriptAnalyzer                    Module     stlpsug              PSScriptAnalyzer provides script anal...\n0.1.15     PSDeploy                            Module     stlpsug              Module to simplify PowerShell based d...\n4.6.0      psake                               Module     stlpsug              psake is a build automation tool writ...\n0.6.1      platyPS                             Module     stlpsug              Generate PowerShell External Help fil...\n1.2        PSReadline                          Module     stlpsug              Great command line editing in the Pow...  That's it!\nWe've deployed  and  registered our very own private PowerShell repository!",
            "title": "Registering Your Private Gallery"
        },
        {
            "location": "/Step-By-Step/5-Publishing-To-Your-Private-Gallery/",
            "text": "Publishing To Your Private Gallery\n\n\nThe final step in using your private gallery is to be able to publish your own modules to your private gallery.\n\n\nPublishing Your First Package\n\n\nThe easiest way to publish to your private gallery is to navigate to the folder in which the module you want to publish is located.\nFor the purposes of this Walkthrough, you can navigate to the \nExampleModules\n folder.\n\n\nYou're going to need the guid you used for the \ngalleryApiKey\n in the build definition. \nIn the below example, \nf3b0edb5-99da-4bef-a66f-4bbd372a45e5\n was the API key used in the build and \nstlpsug\n was what was used for the \ngalleryName\n variable.\n\n\nPublish-Module -Path ExampleModules\\0.1.0 -Repository stlpsug -NugetApiKey 'f3b0edb5-99da-4bef-a66f-4bbd372a45e5'\n\n\n\n\nNote:\n Install NuGet if prompted.\n\n\nIf that worked, we're also going to publish a few more versions of the module:\n\n\nPublish-Module -Path ExampleModule\\0.2.0 -Repository stlpsug -NugetApiKey 'f3b0edb5-99da-4bef-a66f-4bbd372a45e5'\nPublish-Module -Path ExampleModule\\0.1.1 -Repository stlpsug -NugetApiKey 'f3b0edb5-99da-4bef-a66f-4bbd372a45e5'\nPublish-Module -Path ExampleModule\\1.0.0 -Repository stlpsug -NugetApiKey 'f3b0edb5-99da-4bef-a66f-4bbd372a45e5'\n\n\n\n\nYou \nshould\n get an error when trying to publish ExampleModule v0.1.1 - the publishing mechanism does not allow you to publish a version of a module older than those already published to the gallery.\nYou will have to always register your packages in order from lowest version to highest if you want to include older versions of the module.\n\n\nTo see that the packages were in fact published:\n\n\nFind-Module -Name ExampleModule -Repository stlpsug -AllVersions\n\n\n\n\nVersion    Name                                Type       Repository           Description\n-------    ----                                ----       ----------           -----------\n1.0.0      ExampleModule                       Module     stlpsug              Example Module for PSPrivateGalleryWalkthrough\n0.2.0      ExampleModule                       Module     stlpsug              Example Module for PSPrivateGalleryWalkthrough\n0.1.0      ExampleModule                       Module     stlpsug              Example Module for PSPrivateGalleryWalkthrough\n\n\n\n\nAnd there you have it - you've successfully published modules to your private gallery!\nFrom here on out, you can find and install modules from your private gallery the same way you would from the public PSGallery.\n\n\nCongratulations!",
            "title": "5. Publishing To Your Private Gallery"
        },
        {
            "location": "/Step-By-Step/5-Publishing-To-Your-Private-Gallery/#publishing-to-your-private-gallery",
            "text": "The final step in using your private gallery is to be able to publish your own modules to your private gallery.",
            "title": "Publishing To Your Private Gallery"
        },
        {
            "location": "/Step-By-Step/5-Publishing-To-Your-Private-Gallery/#publishing-your-first-package",
            "text": "The easiest way to publish to your private gallery is to navigate to the folder in which the module you want to publish is located.\nFor the purposes of this Walkthrough, you can navigate to the  ExampleModules  folder.  You're going to need the guid you used for the  galleryApiKey  in the build definition. \nIn the below example,  f3b0edb5-99da-4bef-a66f-4bbd372a45e5  was the API key used in the build and  stlpsug  was what was used for the  galleryName  variable.  Publish-Module -Path ExampleModules\\0.1.0 -Repository stlpsug -NugetApiKey 'f3b0edb5-99da-4bef-a66f-4bbd372a45e5'  Note:  Install NuGet if prompted.  If that worked, we're also going to publish a few more versions of the module:  Publish-Module -Path ExampleModule\\0.2.0 -Repository stlpsug -NugetApiKey 'f3b0edb5-99da-4bef-a66f-4bbd372a45e5'\nPublish-Module -Path ExampleModule\\0.1.1 -Repository stlpsug -NugetApiKey 'f3b0edb5-99da-4bef-a66f-4bbd372a45e5'\nPublish-Module -Path ExampleModule\\1.0.0 -Repository stlpsug -NugetApiKey 'f3b0edb5-99da-4bef-a66f-4bbd372a45e5'  You  should  get an error when trying to publish ExampleModule v0.1.1 - the publishing mechanism does not allow you to publish a version of a module older than those already published to the gallery.\nYou will have to always register your packages in order from lowest version to highest if you want to include older versions of the module.  To see that the packages were in fact published:  Find-Module -Name ExampleModule -Repository stlpsug -AllVersions  Version    Name                                Type       Repository           Description\n-------    ----                                ----       ----------           -----------\n1.0.0      ExampleModule                       Module     stlpsug              Example Module for PSPrivateGalleryWalkthrough\n0.2.0      ExampleModule                       Module     stlpsug              Example Module for PSPrivateGalleryWalkthrough\n0.1.0      ExampleModule                       Module     stlpsug              Example Module for PSPrivateGalleryWalkthrough  And there you have it - you've successfully published modules to your private gallery!\nFrom here on out, you can find and install modules from your private gallery the same way you would from the public PSGallery.  Congratulations!",
            "title": "Publishing Your First Package"
        },
        {
            "location": "/Concepts/Build-Variables/",
            "text": "Build Variables\n\n\nBuild variables are where most of the not-magic happens in our build process.\nThey're what we're using (in this case) to deploy our infrastructure.\n\n\nHowever, in a true infrastructure-as-code deployment, we'd use \nmuch\n fewer build variables - essentially, only keeping our secrets (user passwords, API keys, etc) in the build variables.\n\n\nThe reason for this is twofold:\n\n\n\n\nBuild Variables can't transfer to a different build system easily.\nIf you ever decide to use \nAppVeyor\n, \nTravis CI\n, \nJenkins\n, or another continuous integration build system, you will have to define all of the same variables for those builds as well.\n\n\nChanges to Build Variables don't reside in your source control repository and can't be versioned with the templates, configurations, and helper scripts.\nThis means, necessarily, adding a build variabls changelog to your source control repository or splitting your source of truth for builds. While the VSTS build system \ndoes\n allow you to save each edit to the system and include a comment - somewhat like a source control commit - again, this data can't come with you if you change systems. It's also a place to look for changes to your infrastructure \nother\n than your primary source control.\n\n\n\n\nWith those caveats out of the way, let's dive a bit deeper into considerations for the build variables with regard to this project.\n\n\nNaming Build Variables\n\n\nIn general, it's best to give our build variables descriptive names.\nThe person defining the build may not always be the person editing or executing the build so it's good practice to ensure someone can tell at a glance what the variables are used for.\n\n\nThe naming convention of existing build variables in VSTS is \ncamelCase\n.\n\n\nAllow at Queue Time\n\n\nAny variable which you'd like to be able to set at each deploy should be marked for \nAllow at Queue Time\n.\nThis ensures you can override the build's default value for this variable at deployment.\n\n\nThis is particularly important for things like passwords, API keys, and names. \nFor example, if deploying a test version of the gallery, I may not want to use my production credentials and I may want to identify the resource group as one for testing.\n\n\nAgain though, aside from secrets, these changes \nshould\n be made in source control and pushed to the repository if we're following best practices.\n\n\nSecrets\n\n\nMarking a Build Variable as a secret ensures that the variable is encrypted at rest.\nFor more on the security of secrets in VSTS, see this \nreference\n.\n\n\nWe use secrets for our builds because there is some information we do \nnot\n want in source control - namely, passwords and keys.\nSource control for internal projects may (should!) have access control policies, but storing passwords or keys in plain text is still probably not the best idea.\n\n\nFor open source projects, passwords and keys \nmust\n be kept secure and outside of source control because there isn't any access control on viewing the source code.",
            "title": "Build Variables"
        },
        {
            "location": "/Concepts/Build-Variables/#build-variables",
            "text": "Build variables are where most of the not-magic happens in our build process.\nThey're what we're using (in this case) to deploy our infrastructure.  However, in a true infrastructure-as-code deployment, we'd use  much  fewer build variables - essentially, only keeping our secrets (user passwords, API keys, etc) in the build variables.  The reason for this is twofold:   Build Variables can't transfer to a different build system easily.\nIf you ever decide to use  AppVeyor ,  Travis CI ,  Jenkins , or another continuous integration build system, you will have to define all of the same variables for those builds as well.  Changes to Build Variables don't reside in your source control repository and can't be versioned with the templates, configurations, and helper scripts.\nThis means, necessarily, adding a build variabls changelog to your source control repository or splitting your source of truth for builds. While the VSTS build system  does  allow you to save each edit to the system and include a comment - somewhat like a source control commit - again, this data can't come with you if you change systems. It's also a place to look for changes to your infrastructure  other  than your primary source control.   With those caveats out of the way, let's dive a bit deeper into considerations for the build variables with regard to this project.",
            "title": "Build Variables"
        },
        {
            "location": "/Concepts/Build-Variables/#naming-build-variables",
            "text": "In general, it's best to give our build variables descriptive names.\nThe person defining the build may not always be the person editing or executing the build so it's good practice to ensure someone can tell at a glance what the variables are used for.  The naming convention of existing build variables in VSTS is  camelCase .",
            "title": "Naming Build Variables"
        },
        {
            "location": "/Concepts/Build-Variables/#allow-at-queue-time",
            "text": "Any variable which you'd like to be able to set at each deploy should be marked for  Allow at Queue Time .\nThis ensures you can override the build's default value for this variable at deployment.  This is particularly important for things like passwords, API keys, and names. \nFor example, if deploying a test version of the gallery, I may not want to use my production credentials and I may want to identify the resource group as one for testing.  Again though, aside from secrets, these changes  should  be made in source control and pushed to the repository if we're following best practices.",
            "title": "Allow at Queue Time"
        },
        {
            "location": "/Concepts/Build-Variables/#secrets",
            "text": "Marking a Build Variable as a secret ensures that the variable is encrypted at rest.\nFor more on the security of secrets in VSTS, see this  reference .  We use secrets for our builds because there is some information we do  not  want in source control - namely, passwords and keys.\nSource control for internal projects may (should!) have access control policies, but storing passwords or keys in plain text is still probably not the best idea.  For open source projects, passwords and keys  must  be kept secure and outside of source control because there isn't any access control on viewing the source code.",
            "title": "Secrets"
        },
        {
            "location": "/Concepts/The-PowerShell-Private-Gallery-Configurations/",
            "text": "Private Gallery Configurations",
            "title": "The Configurations"
        },
        {
            "location": "/Concepts/The-PowerShell-Private-Gallery-Configurations/#private-gallery-configurations",
            "text": "",
            "title": "Private Gallery Configurations"
        }
    ]
}